fn main() {
    // These lengths and offsets for samples are taken from the entries in instrument_table.
    println!("# Samples");
    for (idx, (l, i)) in [
        (0x8, 0x1412),
        (0x6, 0x1422),
        (0x8, 0x1432),
        (0x4, 0x1442),
        (0x10, 0x144A),
        (0xC, 0x146A),
        (0x4, 0x1482),
        (0x8, 0x148A),
        (0x8, 0x149A),
        (0x9E9, 0x14BA),
        (0x9EA, 0x288C),
        (0x19E, 0x3C60),
        (0x55D, 0x3F9C),
        (0xAED, 0x4A56),
        (0x561, 0x6030),
        (0x53F, 0x6AF2),
        (0x4D4, 0x7570),
        (0x4BD, 0x7F18),
        (0x13C9, 0x8892),
        (0x13C9, 0x8892),
        (0x373C, 0xB024),
        (0x1146, 0x11E9C),
        (0x11FD, 0x14128),
        (0x11F2, 0x16522),
        (0x1D8B, 0x18906),
        (0x40E, 0x1C41C),
        (0x3B7, 0x1CC38),
        (0x3F9, 0x1D3A6),
        (0xA46, 0x1DB98),
        (0x5CA, 0x1F024),
        (0x65F, 0x1FBB8),
        (0x57B, 0x20876),
        (0x6A9, 0x2136C),
        (0xEAF, 0x220BE),
        (0xF85, 0x23E1C),
        (0xFA1, 0x25D26),
        (0xFEC, 0x27C68),
        (0x493, 0x29C40),
        (0xCCF, 0x2A566),
        (0x1146, 0x2BF04),
    ]
    .iter()
    .enumerate()
    {
        // Calculate the actual address from the offset to sound_base.
        let addr = i + 0x0001bc3e;
        // Ghidra python instruction to create label...
        println!(
            "createLabel(toAddr(0x{:x}), \"sound_sample_{}\", True)",
            addr, idx
        );
        // and associated array of words.
        println!("createData(toAddr(0x{:x}), ghidra.program.model.data.ArrayDataType(ghidra.program.model.data.WordDataType(), {}, 2))", addr, l);
    }

    println!("\n# Sequences");
    for (offset, index) in std::iter::zip(
        [
            0xE, 0x4B8, 0x8FF, 0xC31, 0x9B5, 0x9CA, 0x58D, 0x29, 0x728, 0xDD1, 0xFD, 0xE27, 0x73B,
            0x18A, 0x9F1, 0x382, 0x5A0, 0x102B, 0xAFF, 0x10F3, 0x436, 0x80D, 0xB71, 0x137E, 0x138E,
            0x139A,
        ],
        1..,
    ) {
        let addr = offset + 0x0001bc3e;
        println!(
            "createLabel(toAddr(0x{:x}), \"sound_sequence_{}\", True)",
            addr, index
        );
    }

    // And now the same thing for the sounds in overlay #0:

    // These lengths and offsets for samples are taken from the entries in instrument_table_0.
    println!("# Overlay samples");
    for (idx, (l, i)) in [
        (0x8, 0x9f4),
        (0x6, 0xa04),
        (0x8, 0xa14),
        (0x4, 0xa24),
        (0x10, 0xa2c),
        (0xc, 0xa4c),
        (0x4, 0xa64),
        (0x8, 0xa6c),
        (0x8, 0xa7c),
        (0x584, 0xa9c),
        (0x1264, 0x4360),
        (0x1264, 0x4360),
        (0x1264, 0x7ffc),
        (0x3f9, 0x6828),
        (0x8cf, 0xa4c4),
        (0x3c0, 0xb662),
        (0x3a6, 0xbde2),
        (0x864, 0xc52e),
        (0x7bd, 0xd5f6),
        (0x2e9, 0xe570),
        (0x65d, 0xeb42),
        (0x527, 0xf7fc),
        (0x1511, 0x15118), // 22: 0x15118 - 0x17B3A - overlaps with 25, 26, 27.
        (0x39a, 0x1024a),
        (0xf07, 0x1097e),
        (0x80e, 0x15118), // 25: 0x15118 - 0x16134 - overlaps with 22.
        (0x7ea, 0x16134), // 26: 0x16134 - 0x17108 - overlaps with 22.
        (0xbd7, 0x17108), // 27: 0x17108 - 0x188B6 - overlaps with 22.
        (0x374, 0x188b6),
        (0x408, 0x18f9e),
        (0x65d, 0xeb42),
        (0x5c8, 0x197ae),
        (0x8cf, 0x1278c),
        (0x2c1, 0x1392a),
        (0x5b7, 0x15a4),
        (0x5b7, 0x2113),
        (0x5b7, 0x2c82),
        (0x5b8, 0x37f0),
        (0x3f9, 0x701a),
        (0x3f8, 0x780c),
        (0x3f8, 0x780c),
        (0x4b9, 0x13eac),
        (0x47d, 0x1481e),
    ]
    .iter()
    .enumerate()
    {
        // Calculate the actual address from the offset to sound_base.
        let addr = i + 0x0001bc3e;
        // Ghidra python instruction to create label...
        println!(
	    "createLabel(currentProgram.parseAddress(\"overlay0:0x{:x}\")[0], \"sound_sample_0_{}\", True)",
            addr, idx
        );
        // and associated array of words.
        println!("createData(currentProgram.parseAddress(\"overlay0:0x{:x}\")[0], ghidra.program.model.data.ArrayDataType(ghidra.program.model.data.WordDataType(), {}, 2))", addr, l);
    }

    println!("\n# Overlay sequences");
    for (offset, index) in std::iter::zip(
        [
            0x12, 0x1d, 0x28, 0x36, 0x47, 0x55, 0x9b, 0xa9, 0xb7, 0x103, 0x116, 0x59f, 0x121,
            0x12c, 0x13a, 0x15a, 0x17a, 0x18d, 0x19c, 0x1af, 0x1bf, 0x1d7, 0x1f2, 0x1fe, 0x20d,
            0x222, 0x23d, 0x24c, 0x266, 0x284, 0x2c3, 0x2e2, 0x2f8, 0x30e, 0x31c, 0x32c, 0x33a,
            0x350, 0x361, 0x376, 0x38c, 0x437, 0x447, 0x45e, 0x46e, 0x47e, 0x497, 0x524, 0x68a,
            0x6b0, 0x6f0, 0x711, 0x742, 0x77c, 0x791, 0x7a7, 0x7c9, 0x7dc, 0x7ea, 0x826, 0x879,
            0x579, 0x5f4, 0x637, 0x887, 0x897, 0x8aa, 0xca, 0xdd, 0xf0, 0x276, 0x63, 0x71, 0x7f,
            0x8d, 0x2a2, 0x3e0,
        ],
        1..,
    ) {
        let addr = offset + 0x0001bc3e;
        // Is this the right way to do this? Who knows. The Ghidra
        // docs are awful.
        println!(
	    "createLabel(currentProgram.parseAddress(\"overlay0:0x{:x}\")[0], \"sound_sequence_0_{}\", True)",
            addr, index
        );
    }
}
